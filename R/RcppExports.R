# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculates the Pointwise credible interval for the mean
#'
#' @name GetMeanCI_PW
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time Vector containing time points of interest
#' @param k Int containing the cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th pointwise credible functions
#' @export
GetMeanCI_PW <- function(dir, n_files, time, k) {
    .Call('_BayesFPMM_GetMeanCI_PW', PACKAGE = 'BayesFPMM', dir, n_files, time, k)
}

#' Calculates the simultaneous credible interval for the mean
#'
#' @name GetMeanCI_S
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time Vector containing time points of interest
#' @param k Int containing the cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th simultaneous credible functions
#' @export
GetMeanCI_S <- function(dir, n_files, time, k) {
    .Call('_BayesFPMM_GetMeanCI_S', PACKAGE = 'BayesFPMM', dir, n_files, time, k)
}

#' Calculates the Pointwise credible interval for the covariance function between two clusters
#'
#' @name GetCovCI_PW
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time1 Vector containing time points of interest for first cluster
#' @param time2 Vector containing time points of interest for second cluster
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th pointwise credible functions
#' @export
GetCovCI_PW <- function(dir, n_files, n_MCMC, time1, time2, l, m) {
    .Call('_BayesFPMM_GetCovCI_PW', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time1, time2, l, m)
}

#' Calculates the Simultaneous credible interval for the covariance function between two clusters
#'
#' @name GetCovCI_S
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time1 Vector containing time points of interest for first cluster
#' @param time2 Vector containing time points of interest for second cluster
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th simultaneous credible functions
#' @export
GetCovCI_S <- function(dir, n_files, n_MCMC, time1, time2, l, m) {
    .Call('_BayesFPMM_GetCovCI_S', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time1, time2, l, m)
}

#' Calculates the credible interval for sigma squared
#'
#' @name GetSigmaCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Integer containing the number of MCMC files
#' @return CI list containing the 97.5th , 50th, and 2.5th pointwise credible values
#' @export
GetSigmaCI <- function(dir, n_files) {
    .Call('_BayesFPMM_GetSigmaCI', PACKAGE = 'BayesFPMM', dir, n_files)
}

#' Calculates the credible interval for membership parameters Z
#'
#' @name GetZCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Integer containing the number of files per parameter
#' @return CI List containing the 97.5th , 50th, and 2.5th credible values
#' @export
GetZCI <- function(dir, n_files) {
    .Call('_BayesFPMM_GetZCI', PACKAGE = 'BayesFPMM', dir, n_files)
}

#' Calculates the DIC of a model
#'
#' @name Model_DIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @returns DIC Double containing DIC value
#' @export
Model_DIC <- function(dir, n_files, n_MCMC, time, Y) {
    .Call('_BayesFPMM_Model_DIC', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time, Y)
}

#' Calculates the AIC of a model
#'
#' @name Model_AIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @returns DIC Double containing DIC value
#' @export
Model_AIC <- function(dir, n_files, n_MCMC, time, Y) {
    .Call('_BayesFPMM_Model_AIC', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time, Y)
}

#' Calculates the BIC of a model
#'
#' @name Model_BIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @returns DIC Double containing DIC value
#' @export
Model_BIC <- function(dir, n_files, n_MCMC, time, Y) {
    .Call('_BayesFPMM_Model_BIC', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time, Y)
}

#' Find initial starting position for nu and Z parameters for functional data
#'
#' Function for finding a good initial starting point for nu parameters and Z
#' parameters for functional data, with option for tempered transitions. This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations.
#'
#' @name BFPMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param var_pi Double containing variance parameter of the random walk MH for pi parameter
#' @param var_Z Double containing variance parameter of the random walk MH for Z parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epslion1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epslion2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma}}{Sigma samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters = 150
#' n_try = 1
#' k = 2
#' n_funct = 40
#' basis_degree = 3
#' n_eigen = 3
#' boundary_knots = c(0, 1000)
#' internal_knots = c(250, 500, 750)
#'
#' ## Run function
#' x <- BFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                              basis_degree, n_eigen, boundary_knots,
#'                              internal_knots)
#'
#' @export
BFPMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c = NULL, b = 800, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BFPMM_Nu_Z_multiple_try', PACKAGE = 'BayesFPMM', tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Estimates the initial starting point of the rest of the parameters given an initial starting point for Z and nu for functional data
#'
#' @name BFPMM_Theta_Est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param Z_samp Cube containing initial chain of Z parameters from BFPMM_Nu_Z_multiple_try
#' @param nu_samp Cube containing initial chain of nu parameters from BFPMM_Nu_Z_multiple_try
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param k Int containing the number of clusters
#' @param Y Field of vectors containing the observed values
#' @param time Field of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epslion1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epslion2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{chi}}{chi samples from MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from MCMC chain}
#'   \item{\code{sigma}}{sigma samples from MCMC chain}
#'   \item{\code{tau}}{tau samples from MCMC chain}
#'   \item{\code{gamma}}{gamma samples from the chain with the highest average log-likelihood}
#'   \item{\code{Phi}}{Phi samples from MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#' @export
BFPMM_Theta_Est <- function(tot_mcmc_iters, Z_samp, nu_samp, burnin_prop, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c = NULL, b = 1, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BFPMM_Theta_Est', PACKAGE = 'BayesFPMM', tot_mcmc_iters, Z_samp, nu_samp, burnin_prop, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Performs MCMC for functional data, with optional tempered transitions, using user specified starting points
#'
#' @name BFPMM_warm_start
#' @param beta_N_t Double containing the maximum weight for tempered transisitons
#' @param N_t Int containing total number of tempered transitions. If no tempered transitions are desired, pick a small integer
#' @param n_temp_trans Int containing how often tempered transitions are performed. If no tempered transitions are desired, pick a integer larger than tot_mcmc_iters
#' @param tot_mcmc_iters Int containing the number of MCMC iterations
#' @param r_stored_iters Int containing number of MCMC iterations stored in memory before writing to directory
#' @param Z_samp Cube containing initial chain of Z parameters
#' @param pi_samp Matrix containing initial chain of pi parameters
#' @param alpha_3_samp Vector containing initial chain of alpha_3 parameters
#' @param delta_samp Matrix containing initial chain of delta parameters
#' @param gamma_samp Field of cubes containing initial chain of gamma parameters
#' @param Phi_samp Field of cubes containing initial chain of phi parameters
#' @param A_samp Matrix containing initial chain of A parameters
#' @param nu_samp Cube containing initial chain of nu parameters
#' @param tau_samp Matrix containing initial chain of tau parameters
#' @param sigma_samp Vector containing initial chain of sigma parameters
#' @param chi_samp Cube containing initial chain of chi parameters
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param k Int containing the number of clusters
#' @param Y Field of vectors containing the observed values
#' @param time Field of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param thinning_num Int containing how often we should save MCMC iterations. Should be a divisible by r_stored_iters and tot_mcmc_iters
#' @param dir String containing directory where the MCMC files should be saved
#' @export
BFPMM_warm_start <- function(beta_N_t, N_t, n_temp_trans, tot_mcmc_iters, r_stored_iters, Z_samp, pi_samp, alpha_3_samp, delta_samp, gamma_samp, Phi_samp, A_samp, nu_samp, tau_samp, sigma_samp, chi_samp, burnin_prop, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, thinning_num, dir) {
    .Call('_BayesFPMM_BFPMM_warm_start', PACKAGE = 'BayesFPMM', beta_N_t, N_t, n_temp_trans, tot_mcmc_iters, r_stored_iters, Z_samp, pi_samp, alpha_3_samp, delta_samp, gamma_samp, Phi_samp, A_samp, nu_samp, tau_samp, sigma_samp, chi_samp, burnin_prop, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, thinning_num, dir)
}

#' Reads in armadillo vector and returns it in R format
#'
#' @name ReadVec
#' @param file String containing location where arma vector is stored
#' @export
ReadVec <- function(file) {
    .Call('_BayesFPMM_ReadVec', PACKAGE = 'BayesFPMM', file)
}

#' Reads in armadillo matrix and returns it in R format
#'
#' @name ReadMat
#' @param file String containing location where arma matrix is stored
#' @export
ReadMat <- function(file) {
    .Call('_BayesFPMM_ReadMat', PACKAGE = 'BayesFPMM', file)
}

#' Reads in armadillo cube and returns it in R format
#'
#' @name ReadCube
#' @param file String containing location where arma cube is stored
#' @export
ReadCube <- function(file) {
    .Call('_BayesFPMM_ReadCube', PACKAGE = 'BayesFPMM', file)
}

#' Reads in armadillo field of cubes and returns it in R format
#'
#' @name ReadFieldCube
#' @param file String containing location where arma field is stored
#' @export
ReadFieldCube <- function(file) {
    .Call('_BayesFPMM_ReadFieldCube', PACKAGE = 'BayesFPMM', file)
}

#' Reads in armadillo field of matrices and returns it in R format
#'
#' @name ReadFieldMat
#' @param file String containing location where arma field is stored
#' @export
ReadFieldMat <- function(file) {
    .Call('_BayesFPMM_ReadFieldMat', PACKAGE = 'BayesFPMM', file)
}

#' Reads in armadillo field of vectors and returns it in R format
#'
#' @name ReadFieldVec
#' @param file String containing location where arma field is stored
#' @export
ReadFieldVec <- function(file) {
    .Call('_BayesFPMM_ReadFieldVec', PACKAGE = 'BayesFPMM', file)
}

#' Function for finding a good initial starting point for nu parameters and Z parameters for multivariate functional data, with option for temperered transitions
#'
#' @name BMFPMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param k Int containing the number of clusters
#' @param Y Field of vectors containing the observed values
#' @param time field of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots field of vectors containing the internal knots for each dimension
#' @returns BestChain List containing a summary of the best performing chain
#' @export
BMFPMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots) {
    .Call('_BayesFPMM_BMFPMM_Nu_Z_multiple_try', PACKAGE = 'BayesFPMM', tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots)
}

#' Estimates the initial starting point of the rest of the parameters given an initial starting point for Z and nu for multivariate functional data
#'
#' @name BMFPMM_Theta_Est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param Z_samp Cube containing initial chain of Z parameters from BFPMM_Nu_Z_multiple_try
#' @param nu_samp Cube containing initial chain of nu parameters from BFPMM_Nu_Z_multiple_try
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param k Int containing the number of clusters
#' @param Y Field of vectors containing the observed values
#' @param time Field of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @returns BestChain List containing a summary of the chain conditioned on nu and Z
#' @export
BMFPMM_Theta_Est <- function(tot_mcmc_iters, Z_samp, nu_samp, burnin_prop, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots) {
    .Call('_BayesFPMM_BMFPMM_Theta_Est', PACKAGE = 'BayesFPMM', tot_mcmc_iters, Z_samp, nu_samp, burnin_prop, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots)
}

