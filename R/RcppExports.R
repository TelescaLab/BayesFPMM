# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculates the Pointwise credible interval for the mean
#'
#' @name GetMeanCI_PW
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time Vector containing time points of interest
#' @param k Int containing the cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th pointwise credible functions
#' @export
GetMeanCI_PW <- function(dir, n_files, time, k) {
    .Call('_BayesFPMM_GetMeanCI_PW', PACKAGE = 'BayesFPMM', dir, n_files, time, k)
}

#' Calculates the simultaneous credible interval for the mean
#'
#' @name GetMeanCI_S
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param time Vector containing time points of interest
#' @param k Int containing the cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th simultaneous credible functions
#' @export
GetMeanCI_S <- function(dir, n_files, time, k) {
    .Call('_BayesFPMM_GetMeanCI_S', PACKAGE = 'BayesFPMM', dir, n_files, time, k)
}

#' Calculates the Pointwise credible interval for the covariance function between two clusters
#'
#' @name GetCovCI_PW
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time1 Vector containing time points of interest for first cluster
#' @param time2 Vector containing time points of interest for second cluster
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th pointwise credible functions
#' @export
GetCovCI_PW <- function(dir, n_files, n_MCMC, time1, time2, l, m) {
    .Call('_BayesFPMM_GetCovCI_PW', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time1, time2, l, m)
}

#' Calculates the Simultaneous credible interval for the covariance function between two clusters
#'
#' @name GetCovCI_S
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time1 Vector containing time points of interest for first cluster
#' @param time2 Vector containing time points of interest for second cluster
#' @param l Int containing the 1st cluster group of which you want to get the credible interval for
#' @param m Int containing the 2nd cluster group of which you want to get the credible interval for
#' @return CI list containing the 97.5th , 50th, and 2.5th simultaneous credible functions
#' @export
GetCovCI_S <- function(dir, n_files, n_MCMC, time1, time2, l, m) {
    .Call('_BayesFPMM_GetCovCI_S', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time1, time2, l, m)
}

#' Calculates the credible interval for sigma squared
#'
#' @name GetSigmaCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Integer containing the number of MCMC files
#' @return CI list containing the 97.5th , 50th, and 2.5th pointwise credible values
#' @export
GetSigmaCI <- function(dir, n_files) {
    .Call('_BayesFPMM_GetSigmaCI', PACKAGE = 'BayesFPMM', dir, n_files)
}

#' Calculates the credible interval for membership parameters Z
#'
#' @name GetZCI
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Integer containing the number of files per parameter
#' @return CI List containing the 97.5th , 50th, and 2.5th credible values
#' @export
GetZCI <- function(dir, n_files) {
    .Call('_BayesFPMM_GetZCI', PACKAGE = 'BayesFPMM', dir, n_files)
}

#' Calculates the DIC of a model
#'
#' @name Model_DIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @returns DIC Double containing DIC value
#' @export
Model_DIC <- function(dir, n_files, n_MCMC, time, Y) {
    .Call('_BayesFPMM_Model_DIC', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time, Y)
}

#' Calculates the AIC of a model
#'
#' @name Model_AIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @returns DIC Double containing DIC value
#' @export
Model_AIC <- function(dir, n_files, n_MCMC, time, Y) {
    .Call('_BayesFPMM_Model_AIC', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time, Y)
}

#' Calculates the BIC of a model
#'
#' @name Model_BIC
#' @param dir String containing the directory where the MCMC files are located
#' @param n_files Int containing the number of files per parameter
#' @param n_MCMC Int containing the number of saved MCMC iterations per file
#' @param time Field of vectors containing time points at which the function was observed
#' @param Y Field of vectors containing observed values of the function
#' @returns DIC Double containing DIC value
#' @export
Model_BIC <- function(dir, n_files, n_MCMC, time, Y) {
    .Call('_BayesFPMM_Model_BIC', PACKAGE = 'BayesFPMM', dir, n_files, n_MCMC, time, Y)
}

#' Find initial starting position for nu and Z parameters for functional data
#'
#' Function for finding a good initial starting point for nu parameters and Z
#' parameters for functional data, with option for tempered transitions. This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations.
#'
#' @name BFPMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma}}{Sigma samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Run function
#' x <- BFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                              basis_degree, n_eigen, boundary_knots,
#'                              internal_knots)
#'
#' @export
BFPMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c = NULL, b = 800, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BFPMM_Nu_Z_multiple_try', PACKAGE = 'BayesFPMM', tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Find initial starting points for parameters given nu and Z parameters
#'
#' This function is meant to be used after using \code{BFPMM_NU_Z_multiple_try}.
#' This function samples from the rest of the model parameters given a fixed value of
#' nu and Z. The fixed value of nu and Z are found by using the best markov chain
#' found in \code{BFPMM_NU_Z_multiple_try}. Once this function is ran, the results
#' can be used in \code{BFPMM_warm_start}.
#'
#' @name BFPMM_Theta_est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param Z_samp Cube containing initial chain of Z parameters from \code{BFPMM_Nu_Z_multiple_try}
#' @param nu_samp Cube containing initial chain of nu parameters from \code{BFPMM_Nu_Z_multiple_try}
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{chi}}{chi samples from MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from MCMC chain}
#'   \item{\code{sigma}}{sigma samples from MCMC chain}
#'   \item{\code{tau}}{tau samples from MCMC chain}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots)
#'
#' ## Run function
#' est2 <- BFPMM_Theta_est(tot_mcmc_iters, k, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1$Z, est1$nu)
#'
#' @export
BFPMM_Theta_est <- function(tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, nu_samp, burnin_prop = 0.8, c = NULL, b = 1, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BFPMM_Theta_est', PACKAGE = 'BayesFPMM', tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, nu_samp, burnin_prop, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Performs MCMC for functional model given an informed set of starting points
#'
#' This function is meant to be used after using \code{BFPMM_Nu_Z_multiple_try}
#' and \code{BFPMM_Theta_est}. This function will use the outputs of these two
#' functions to start the MCMC chain in a good location. Since the posterior distribution
#' can often be multimodal, it is important to have a good starting position.
#' To help move across modes, this function allows users to use tempered transitions
#' every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
#' and un-tempered transitions, we can allow the chain to explore multiple modes without
#' while keeping sampling relatively computationally efficient. To save on RAM usage, we
#' allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
#' If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
#' of the chain is stored in the user specified directory (\code{dir}). The samples from each
#' parameter can be viewed using the following functions: \code{ReadFieldCube},
#' \code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
#' \code{ReadVec}.
#'
#' @name BFPMM_warm_start
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of vectors containing the observed time points
#' @param n_funct Int containing the number of functions
#' @param basis_degree Int containing the degree of B-splines used
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Vector containing the boundary points of our index domain of interest
#' @param internal_knots Vector location of internal knots for B-splines
#' @param Z_samp Cube containing initial chain of Z parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param pi_samp Matrix containing initial chain of pi parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param alpha_3_samp Vector containing initial chain of alpha_3 parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param delta_samp Matrix containing initial chain of delta parameters (from \code{BFPMM_Theta_est})
#' @param gamma_samp List of cubes containing initial chain of gamma parameters (from \code{BFPMM_Theta_est})
#' @param Phi_samp List of cubes containing initial chain of phi parameters (from \code{BFPMM_Theta_est})
#' @param A_samp Matrix containing initial chain of A parameters (from \code{BFPMM_Theta_est})
#' @param nu_samp Cube containing initial chain of nu parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param tau_samp Matrix containing initial chain of tau parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param sigma_samp Vector containing initial chain of sigma parameters (from \code{BFPMM_Theta_est})
#' @param chi_samp Cube containing initial chain of chi parameters (from \code{BFPMM_Theta_est})
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param dir String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)
#' @param thinning_num Int containing how often we should save MCMC iterations
#' @param beta_N_t Double containing the maximum weight for tempered transitions
#' @param N_t Int containing total number of tempered transitions
#' @param n_temp_trans Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)
#' @param r_stored_iters Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#'
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the MCMC chain}
#'   \item{\code{chi}}{chi samples from the MCMC chain}
#'   \item{\code{pi}}{pi samples from the MCMC chain}
#'   \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from the MCMC chain}
#'   \item{\code{sigma}}{sigma samples from the MCMC chain}
#'   \item{\code{tau}}{tau samples from the MCMC chain}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from the MCMC chain}
#'   \item{\code{Z}}{Z samples from the MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
#'   \item{\code{n_thinning}}{must be a positive integer}
#'   \item{\code{beta_N_t}}{must be between 1 and 0}
#'   \item{\code{N_t}}{must be a positive integer}
#'   \item{\code{n_temp_trans}}{must be a non-negative integer}
#'   \item{\code{r_stored_iters}}{must be a non-negative integer}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#'@examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "Sim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "time.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_funct <- 40
#' basis_degree <- 3
#' n_eigen <- 3
#' boundary_knots <- c(0, 1000)
#' internal_knots <- c(250, 500, 750)
#'
#' ## Get Estimates of Z and nu
#' est1 <- BFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots)
#'
#' ## Get estimates of other parameters
#' est2 <- BFPMM_Theta_est(tot_mcmc_iters, k, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1$Z, est1$nu)
#'
#' MCMC.chain <-BFPMM_warm_start(tot_mcmc_iters, k, Y, time, n_funct,
#'                               basis_degree, n_eigen, boundary_knots,
#'                               internal_knots, est1$Z, est1$pi, est1$alpha_3,
#'                               est2$delta, est2$gamma, est2$Phi, est2$A,
#'                               est1$nu, est1$tau, est2$sigma, est2$chi)
#'
#' @export
BFPMM_warm_start <- function(tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, pi_samp, alpha_3_samp, delta_samp, gamma_samp, Phi_samp, A_samp, nu_samp, tau_samp, sigma_samp, chi_samp, burnin_prop = 0.8, dir = NULL, thinning_num = 1, beta_N_t = 1, N_t = 1L, n_temp_trans = 0L, r_stored_iters = 0L, c = NULL, b = 1, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BFPMM_warm_start', PACKAGE = 'BayesFPMM', tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, pi_samp, alpha_3_samp, delta_samp, gamma_samp, Phi_samp, A_samp, nu_samp, tau_samp, sigma_samp, chi_samp, burnin_prop, dir, thinning_num, beta_N_t, N_t, n_temp_trans, r_stored_iters, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Reads saved parameter data (sigma, alpha_3)
#'
#' Reads armadillo vector type data and returns it as a vector in R. The following
#' parameters can be read in using this function: sigma and alpha_3.
#'
#' @name ReadVec
#' @param file String containing location where armadillo vector is stored
#' @returns Vec Vector containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "sigma.txt", package = "BayesFPMM")
#'
#' ## Read in file
#' sigma <- ReadVec(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set directory
#' # dir <- "~/sigma"
#' #
#' ## initialize placeholder
#' # sigma <- rep(0, n_files * n_samp)
#' # for(i in 0:(n_files - 1)){
#' #   sigma_i <- ReadVec(paste(dir, as.character(i),".txt", sep = ""))
#' #   sigma[((n_samp * i) + 1):(n_samp * (i+1))] <- sigma_i
#' #}
#' #############################################################
#'
#' @export
ReadVec <- function(file) {
    .Call('_BayesFPMM_ReadVec', PACKAGE = 'BayesFPMM', file)
}

#' Reads saved parameter data (pi, A, delta, tau)
#'
#' Reads armadillo matrix type data and returns it as a matirx in R. The following
#' parameters can be read in using this function: pi, A, delta, and tau.
#'
#' @name ReadMat
#' @param file String containing location where armadillo matrix is stored
#' @returns Mat Matrix containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "pi.txt", package = "BayesFPMM")
#'
#' ## Read in file
#' pi <- ReadMat(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set dim of parameter
#' # dim <- 3
#' #
#' ## Set directory
#' # dir <- "~/pi"
#' #
#' ## initialize placeholder
#' # pi <- mat(0, dim, n_files * n_samp)
#' # for(i in 0:(n_files - 1)){
#' #   pi_i <- ReadVec(paste(dir, as.character(i),".txt", sep = ""))
#' #   pi[,((n_samp * i) + 1):(n_samp * (i+1))] <- pi_i
#' #}
#' #############################################################
#'
#' @export
ReadMat <- function(file) {
    .Call('_BayesFPMM_ReadMat', PACKAGE = 'BayesFPMM', file)
}

#' Reads saved parameter data (nu, chi, Z)
#'
#' Reads armadillo cube type data and returns it as an array in R. The following
#' parameters can be read in using this function: nu, chi, and Z.
#'
#' @name ReadCube
#' @param file String containing location where armadillo cube is stored
#' @returns Cube Array containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "nu.txt", package = "BayesFPMM")
#'
#' ## Read in file
#' nu <- ReadCube(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set dim of parameter
#' # dim1 <- 3
#' # dim2 <- 8
#' #
#' ## Set directory
#' # dir <- "~/nu"
#' #
#' ## initialize placeholder
#' # nu <- array(0, dim = c(dim1, dim2, n_files * n_samp))
#' # for(i in 0:(n_files - 1)){
#' #   nu_i <- ReadVec(paste(dir, as.character(i),".txt", sep = ""))
#' #   nu[,,((n_samp * i) + 1):(n_samp * (i+1))] <- pi_i
#' #}
#' #############################################################
#'
#' @export
ReadCube <- function(file) {
    .Call('_BayesFPMM_ReadCube', PACKAGE = 'BayesFPMM', file)
}

#' Reads saved parameter data (gamma, Phi)
#'
#' Reads armadillo field of cubes type data and returns it as a list of arrays
#' in R. The following parameters can be read in using this function: gamma and
#' Phi.
#'
#' @name ReadFieldCube
#' @param file String containing location where armadillo field of cubes is stored
#' @returns FieldCube List of arrays containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "Phi.txt", package = "BayesFPMM")
#'
#' ## Read in file
#' Phi <- ReadFieldCube(file)
#'
#' #############################################################
#' ## For reading in a group of files you can use the following:
#' #
#' ## Set number of files you want to read in
#' # n_files <- 50
#' #
#' ## Set number of samples per file
#' # n_samp <- 100
#' #
#' ## Set dim of parameter
#' # dim1 <- 3
#' # dim2 <- 8
#' # dim3 <- 2
#' #
#' ## Set directory
#' # dir <- "~/nu"
#' #
#' ## initialize placeholder
#' # Phi <- array(0, dim = c(dim1, dim2, dim3, n_files * n_samp))
#' # for(i in 0:(n_files - 1)){
#' #   nu_i <- ReadVec(paste(dir, as.character(i),".txt", sep = ""))
#' #   nu[,,((n_samp * i) + 1):(n_samp * (i+1))] <- pi_i
#' #}
#' #############################################################
#'
#' @export
ReadFieldCube <- function(file) {
    .Call('_BayesFPMM_ReadFieldCube', PACKAGE = 'BayesFPMM', file)
}

#' Reads saved armadillo data
#'
#' Reads armadillo field of matrices type data and returns it as a list of matrices
#' in R.
#'
#' @name ReadFieldMat
#' @param file String containing location where armadillo field of matrices is stored
#' @returns FieldMatrix List of matrices containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "fieldmat.txt", package = "BayesFPMM")
#'
#' ## Read in file
#' samp_data <- ReadFieldMat(file)
#'
#' @export
ReadFieldMat <- function(file) {
    .Call('_BayesFPMM_ReadFieldMat', PACKAGE = 'BayesFPMM', file)
}

#' Reads saved armadillo data
#'
#' Reads armadillo field of vectors type data and returns it as a list of vectors
#' in R.
#'
#' @name ReadFieldVec
#' @param file String containing location where armadillo field of vectors is stored
#' @returns FieldVec List of vectors containing the saved data
#'
#' @examples
#' ## set file path
#' file <- system.file("test-data", "fieldvec.txt", package = "BayesFPMM")
#'
#' ## Read in file
#' samp_data <- ReadFieldVec(file)
#'
#' @export
ReadFieldVec <- function(file) {
    .Call('_BayesFPMM_ReadFieldVec', PACKAGE = 'BayesFPMM', file)
}

#' Find initial starting position for nu and Z parameters for high dimensional functional data (Domain dimension > 1)
#'
#' Function for finding a good initial starting point for nu parameters and Z
#' parameters for functional data, with option for tempered transitions. This
#' function was constructed to handle data in which the domain has dimension
#' greater than 1 (i.e. a surface or higher dimensional function). This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations.
#'
#' @name BHDFPMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values (flattened)
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma}}{Sigma samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{each element must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of corresponding \code{boundary_knots}}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Run function
#' est1 <- BHDFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots)
#'
#' @export
BHDFPMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c = NULL, b = 800, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BHDFPMM_Nu_Z_multiple_try', PACKAGE = 'BayesFPMM', tot_mcmc_iters, n_try, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Find initial starting points for parameters given nu and Z parameters for high dimensional functional data (Domain dimension > 1)
#'
#' This function is meant to be used after using \code{BHDFPMM_NU_Z_multiple_try}.
#' This function samples from the rest of the model parameters given a fixed value of
#' nu and Z. The fixed value of nu and Z are found by using the best markov chain
#' found in \code{BHDFPMM_NU_Z_multiple_try}. Once this function is ran, the results
#' can be used in \code{BHDFPMM_warm_start}.
#'
#' @name BHDFPMM_Theta_est
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values (flattened)
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param Z_samp Cube containing initial chain of Z parameters from \code{BHDFPMM_Nu_Z_multiple_try}
#' @param nu_samp Cube containing initial chain of nu parameters from \code{BHDFPMM_Nu_Z_multiple_try}
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{chi}}{chi samples from MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from MCMC chain}
#'   \item{\code{sigma}}{sigma samples from MCMC chain}
#'   \item{\code{tau}}{tau samples from MCMC chain}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Run function
#' est1 <- BHDFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots)
#'
#' ## Run function
#' est2 <- BHDFPMM_Theta_est(tot_mcmc_iters, k, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1$Z, est1$nu)
#'
#' @export
BHDFPMM_Theta_est <- function(tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, nu_samp, burnin_prop = 0.8, c = NULL, b = 1, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BHDFPMM_Theta_est', PACKAGE = 'BayesFPMM', tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, nu_samp, burnin_prop, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Performs MCMC for high dimensional functional model given an informed set of starting points
#'
#' This function is meant to be used after using \code{BHDFPMM_Nu_Z_multiple_try}
#' and \code{BHDFPMM_Theta_est}. This function will use the outputs of these two
#' functions to start the MCMC chain in a good location. Since the posterior distribution
#' can often be multimodal, it is important to have a good starting position.
#' To help move across modes, this function allows users to use tempered transitions
#' every \code{n_temp_trans} iterations. By using a mixture of tempered transitions
#' and un-tempered transitions, we can allow the chain to explore multiple modes without
#' while keeping sampling relatively computationally efficient. To save on RAM usage, we
#' allow users to specify how many samples are kept in memory using \code{r_stored_iters}.
#' If \code{r_stored_iters} is less than \code{tot_mcmc_iters}, then a thinned version
#' of the chain is stored in the user specified directory (\code{dir}). The samples from each
#' parameter can be viewed using the following functions: \code{ReadFieldCube},
#' \code{ReadFieldMat}, \code{ReadFieldVec}, \code{ReadCube}, \code{ReadMat},
#' \code{ReadVec}.
#'
#' @name BHDFPMM_warm_start
#' @param tot_mcmc_iters Int containing the total number of MCMC iterations
#' @param k Int containing the number of clusters
#' @param Y List of vectors containing the observed values
#' @param time List of matrices that contain the observed time points (each column is a dimension)
#' @param n_funct Int containing the number of functions
#' @param basis_degree Vector containing the desired basis degree for each dimension
#' @param n_eigen Int containing the number of eigenfunctions
#' @param boundary_knots Matrix containing the boundary knots for each dimension (each row is a dimension)
#' @param internal_knots List of vectors containing the internal knots for each dimension
#' @param Z_samp Cube containing initial chain of Z parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param pi_samp Matrix containing initial chain of pi parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param alpha_3_samp Vector containing initial chain of alpha_3 parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param delta_samp Matrix containing initial chain of delta parameters (from \code{BFPMM_Theta_est})
#' @param gamma_samp List of cubes containing initial chain of gamma parameters (from \code{BFPMM_Theta_est})
#' @param Phi_samp List of cubes containing initial chain of phi parameters (from \code{BFPMM_Theta_est})
#' @param A_samp Matrix containing initial chain of A parameters (from \code{BFPMM_Theta_est})
#' @param nu_samp Cube containing initial chain of nu parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param tau_samp Matrix containing initial chain of tau parameters (from \code{BFPMM_NU_Z_multiple_try})
#' @param sigma_samp Vector containing initial chain of sigma parameters (from \code{BFPMM_Theta_est})
#' @param chi_samp Cube containing initial chain of chi parameters (from \code{BFPMM_Theta_est})
#' @param burnin_prop Double containing proportion of chain used to estimate the starting point of nu parameters and Z parameters
#' @param dir String containing directory where the MCMC files should be saved (if NULL, then no files will be saved)
#' @param thinning_num Int containing how often we should save MCMC iterations
#' @param beta_N_t Double containing the maximum weight for tempered transitions
#' @param N_t Int containing total number of tempered transitions
#' @param n_temp_trans Int containing how often tempered transitions are performed (if 0, then no tempered transitions are performed)
#' @param r_stored_iters Int containing how many MCMC iterations are stored in RAM (if 0, then all MCMC iterations are stored in RAM)
#' @param c Vector containing hyperparmeter for sampling from pi (If left NULL, the one vector will be used)
#' @param b double containing hyperparamete for sampling from alpha_3
#' @param nu_1 double containing hyperparameter for sampling from gamma
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparameter for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#'
#' @returns a List containing:
#' \describe{
#'   \item{\code{B}}{The basis functions evaluated at the observed time points}
#'   \item{\code{nu}}{Nu samples from the MCMC chain}
#'   \item{\code{chi}}{chi samples from the MCMC chain}
#'   \item{\code{pi}}{pi samples from the MCMC chain}
#'   \item{\code{alpha_3}}{alpha_3 samples from the MCMC chain}
#'   \item{\code{A}}{A samples from MCMC chain}
#'   \item{\code{delta}}{delta samples from the MCMC chain}
#'   \item{\code{sigma}}{sigma samples from the MCMC chain}
#'   \item{\code{tau}}{tau samples from the MCMC chain}
#'   \item{\code{gamma}}{gamma samples from the MCMC chain}
#'   \item{\code{Phi}}{Phi samples from the MCMC chain}
#'   \item{\code{Z}}{Z samples from the MCMC chain}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{burnin_prop}}{must be between 0 and 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_funct}}{must be an integer larger than 1}
#'   \item{\code{basis_degree}}{must be an integer larger than or equal to 1}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{internal_knots}}{must lie in the range of \code{boundary_knots}}
#'   \item{\code{dir}}{must be specified if \code{r_stored_iters} <= \code{tot_mcmc_iters} (other than if \code{r_stored_iters} = 0)}
#'   \item{\code{n_thinning}}{must be a positive integer}
#'   \item{\code{beta_N_t}}{must be between 1 and 0}
#'   \item{\code{N_t}}{must be a positive integer}
#'   \item{\code{n_temp_trans}}{must be a non-negative integer}
#'   \item{\code{r_stored_iters}}{must be a non-negative integer}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{nu_1}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#'@examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "HDSim_data.RDS", package = "BayesFPMM"))
#' time <- readRDS(system.file("test-data", "HDtime.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_funct <- 20
#' basis_degree <- c(2,2)
#' n_eigen <- 2
#' boundary_knots <- matrix(c(0, 0, 990, 990), nrow = 2)
#' internal_knots <- rep(list(c(250, 500, 750)), 2)
#'
#' ## Run function
#' est1 <- BHDFPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, time, n_funct,
#'                                   basis_degree, n_eigen, boundary_knots,
#'                                   internal_knots)
#'
#' ## Run function
#' est2 <- BHDFPMM_Theta_est(tot_mcmc_iters, k, Y, time, n_funct,
#'                         basis_degree, n_eigen, boundary_knots,
#'                         internal_knots, est1$Z, est1$nu)
#'
#' MCMC.chain <-BHDFPMM_warm_start(tot_mcmc_iters, k, Y, time, n_funct,
#'                                 basis_degree, n_eigen, boundary_knots,
#'                                 internal_knots, est1$Z, est1$pi, est1$alpha_3,
#'                                 est2$delta, est2$gamma, est2$Phi, est2$A,
#'                                 est1$nu, est1$tau, est2$sigma, est2$chi)
#'
#' @export
BHDFPMM_warm_start <- function(tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, pi_samp, alpha_3_samp, delta_samp, gamma_samp, Phi_samp, A_samp, nu_samp, tau_samp, sigma_samp, chi_samp, burnin_prop = 0.8, dir = NULL, thinning_num = 1, beta_N_t = 1, N_t = 1L, n_temp_trans = 0L, r_stored_iters = 0L, c = NULL, b = 1, nu_1 = 3, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BHDFPMM_warm_start', PACKAGE = 'BayesFPMM', tot_mcmc_iters, k, Y, time, n_funct, basis_degree, n_eigen, boundary_knots, internal_knots, Z_samp, pi_samp, alpha_3_samp, delta_samp, gamma_samp, Phi_samp, A_samp, nu_samp, tau_samp, sigma_samp, chi_samp, burnin_prop, dir, thinning_num, beta_N_t, N_t, n_temp_trans, r_stored_iters, c, b, nu_1, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

#' Find initial starting position for nu and Z parameters for multivariate data
#'
#' Function for finding a good initial starting point for nu parameters and Z
#' parameters for multivariate data, with option for tempered transitions.This
#' function tries running multiple different MCMC chains to find the optimal
#' starting position. This function will return the chain that has the highest
#' log-likelihood average in the last 100 MCMC iterations.
#'
#' @name BMVPMM_Nu_Z_multiple_try
#' @param tot_mcmc_iters Int containing the number of MCMC iterations per try
#' @param n_try Int containing how many different chains are tried
#' @param k Int containing the number of clusters
#' @param Y Matrix of observed vectors (each row is n observation)
#' @param n_eigen Int containing the number of eigenfunctions
#' @param c Vector containing hyperparmeters for sampling from pi (If left NULL, the one vector will be used)
#' @param b Double containing hyperparameter for sampling from alpha_3
#' @param alpha1l Double containing hyperparameter for sampling from A
#' @param alpha2l Double containing hyperparameter for sampling from A
#' @param beta1l Double containing hyperparameter for sampling from A
#' @param beta2l Double containing hyperparameter for sampling from A
#' @param a_Z_PM Double containing hyperparameter of the random walk MH for Z parameter
#' @param a_pi_PM Double containing hyperparameter of the random walk MH for pi parameter
#' @param var_alpha3 Double containing variance parameter of the random walk MH for alpha_3 parameter
#' @param var_epsilon1 Double containing hyperparameters for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param var_epsilon2 Double containing hyperparamete for sampling from A having to do with variance for Metropolis-Hastings algorithm
#' @param alpha Double containing hyperparameter for sampling from tau
#' @param beta Double containing hyperparameter for sampling from tau
#' @param alpha_0 Double containing hyperparameter for sampling from sigma
#' @param beta_0 Double containing hyperparameter for sampling from sigma
#' @returns a List containing:
#' \describe{
#'   \item{\code{nu}}{Nu samples from the chain with the highest average log-likelihood}
#'   \item{\code{pi}}{Pi samples from the chain with the highest average log-likelihood}
#'   \item{\code{alpha_3}}{Alpha_3 samples from the chain with the highest average log-likelihood}
#'   \item{\code{A}}{A samples from the chain with the highest average log-likelihood}
#'   \item{\code{delta}}{Delta samples from the chain with the highest average log-likelihood}
#'   \item{\code{sigma}}{Sigma samples from the chain with the highest average log-likelihood}
#'   \item{\code{tau}}{Tau samples from the chain with the highest average log-likelihood}
#'   \item{\code{Z}}{Z samples from the chain with the highest average log-likelihood}
#'   \item{\code{loglik}}{Log-likelihood plot of best performing chain}
#' }
#'
#' @section Warning:
#' The following must be true:
#' \describe{
#'   \item{\code{tot_mcmc_iters}}{must be an integer larger than or equal to 100}
#'   \item{\code{n_try}}{must be an integer larger than or equal to 1}
#'   \item{\code{k}}{must be an integer larger than or equal to 2}
#'   \item{\code{n_eigen}}{must be greater than or equal to 1}
#'   \item{\code{c}}{must be greater than 0 and have k elements}
#'   \item{\code{b}}{must be positive}
#'   \item{\code{alpha1l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{alpha2l}}{must be positive}
#'   \item{\code{beta1l}}{must be positive}
#'   \item{\code{a_Z_PM}}{must be positive}
#'   \item{\code{a_pi_PM}}{must be positive}
#'   \item{\code{var_alpha3}}{must be positive}
#'   \item{\code{var_epsilon1}}{must be positive}
#'   \item{\code{var_epsilon2}}{must be positive}
#'   \item{\code{alpha}}{must be positive}
#'   \item{\code{beta}}{must be positive}
#'   \item{\code{alpha_0}}{must be positive}
#'   \item{\code{beta_0}}{must be positive}
#' }
#'
#' @examples
#' ## Load sample data
#' Y <- readRDS(system.file("test-data", "MVSim_data.RDS", package = "BayesFPMM"))
#'
#' ## Set Hyperparameters
#' tot_mcmc_iters <- 150
#' n_try <- 1
#' k <- 2
#' n_eigen <- 2
#'
#' ## Run function
#' est1 <- BMVPMM_Nu_Z_multiple_try(tot_mcmc_iters, n_try, k, Y, n_eigen)
#'
#' @export
BMVPMM_Nu_Z_multiple_try <- function(tot_mcmc_iters, n_try, k, Y, n_eigen, c = NULL, b = 800, alpha1l = 2, alpha2l = 3, beta1l = 1, beta2l = 1, a_Z_PM = 1000, a_pi_PM = 1000, var_alpha3 = 0.05, var_epsilon1 = 1, var_epsilon2 = 1, alpha = 1, beta = 10, alpha_0 = 1, beta_0 = 1) {
    .Call('_BayesFPMM_BMVPMM_Nu_Z_multiple_try', PACKAGE = 'BayesFPMM', tot_mcmc_iters, n_try, k, Y, n_eigen, c, b, alpha1l, alpha2l, beta1l, beta2l, a_Z_PM, a_pi_PM, var_alpha3, var_epsilon1, var_epsilon2, alpha, beta, alpha_0, beta_0)
}

